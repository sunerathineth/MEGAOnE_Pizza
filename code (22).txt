Main class,


package mega_one_console_version;

import Components.CustomizedPizza;
import Components.DataRepository;
import Components.Feedback;
import Components.Order;
import Components.Payment;
import Components.Pizza;
import Design_Patterns.PizzaBuilder;
import Components.Promotion;
import Components.User;
import java.time.LocalDate;
import java.time.Month;
import java.util.Arrays;
import java.util.Scanner;

import Design_Patterns.*;
import java.util.ArrayList;

import External.*;
import static External.DeliveryEstimator.calculateDeliveryTime;
import static External.DeliveryEstimator.getCoordinatesFromPlace;
import static External.DeliveryEstimator.getUserCountry;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class MEGA_ONE_Console_Version {

    private Scanner scanner;
    private static String userInput;
    private static int userInputInt;
    private static MEGA_ONE_Console_Version megaOne = new MEGA_ONE_Console_Version();
    User activeUser;
    private String userDeliveryAddress;
    private PromotionManager promotionManager;
//    private Timer timer;
    
    // Topping limits
    
    private static final int minToppings = 1;
    private static final int maxToppings = 4;

    // Data center
    
    private static DataRepository repository;
    
    // Repositories
    

    public MEGA_ONE_Console_Version() {
        scanner = new Scanner(System.in);
        repository = new DataRepository();
//        timer = new Timer();
    }

    private String getUserInput(String question) {
        System.out.print(question);
        userInput = scanner.nextLine();
        System.out.println("");
        return userInput;
    }
    
    private int getUserInput_Int(String question) {
        System.out.print(question);
        userInputInt = scanner.nextInt();
        System.out.println("");
        return userInputInt;
    }

    private String returnUserInput() {
        return userInput;
    }

    private void displayUserInput() {
        System.out.println(userInput);
    }
    
    private void pizzaFromMEGAOnE() {
        repository.addPizza(new Pizza("Chicken Kottu Pizza", "A fusion pizza with shredded roti, chicken, vegetables, and spices", "Thin", "Spicy Tomato", "Medium", Arrays.asList("Chicken", "Roti", "Onions", "Chili"), 1800.00, 4.5));
        repository.addPizza(new Pizza("Seafood Lagoon Pizza", "Pizza with prawns, calamari, crab, and a touch of chili", "Thin", "Garlic Butter", "Large", Arrays.asList("Prawns", "Calamari", "Crab", "Chili"), 2500.00, 4.6));
        repository.addPizza(new Pizza("Spicy Chicken Tikka Masala Pizza", "Pizza with a creamy tikka masala sauce, chicken, and onions", "Thick", "Tikka Masala", "Medium", Arrays.asList("Chicken", "Tikka Masala Sauce", "Onions"), 2000.00, 4.3));
        repository.addPizza(new Pizza("Vegetable Curry Pizza", "A vegetarian pizza with mixed vegetable curry, coconut milk, and spices", "Thick", "Coconut Curry", "Small", Arrays.asList("Mixed Vegetables", "Coconut Milk", "Spices"), 1500.00, 4.0));
        repository.addPizza(new Pizza("Devilled Chicken Pizza", "A fiery pizza with devilled chicken, onions, and peppers", "Thin", "Devilled Sauce", "Large", Arrays.asList("Devilled Chicken", "Onions", "Bell Peppers"), 2200.00, 4.7));
    }
    
    private void userCreation() {
        activeUser = new User("Sunera Amaraguru", "suneraedu@gmail.com", "0719427485");
        
        // First time sign up points
        
        activeUser.addLoyaltyPoiints(200);
        
        repository.addUser(activeUser);
    }

    public void displayMainMenu() {
        System.out.println("\nWelcome to MEGA OnE Pizza");
        System.out.println("1. Place a new order");
        System.out.println("2. View pizza menu");
        System.out.println("3. My profile");
        System.out.println("4. My favorites");
        System.out.println("5. View order history");
        System.out.println("6. Track order");
        System.out.println("7. View promotions");
        System.out.println("8. Provide feedback");
        System.out.println("9. View all feedback");
        System.out.println("10. Top rated pizza");
        System.out.println("11. Exit\n");
    }
    
    private static String formatDeliveryTime(double timeInMinutes) {
        if (timeInMinutes < 60) {
            return String.format("%.1f minutes", timeInMinutes);
        } else if (timeInMinutes >= 60 && timeInMinutes < 1440) {
            double hours = timeInMinutes / 60;
            return String.format("%.1f hours", hours);
        } else {
            double days = timeInMinutes / 1440;
            return String.format("%.1f days", days);
        }
    }
    
    private void acceptPayment(double amount) {
        PaymentProcessor paymentProcessor = new PaymentProcessor();
        boolean paymentSuccessful = false;

        while (!paymentSuccessful) {
            System.out.println("\nSelect Payment Method:");
            System.out.println("1. Credit Card");
            System.out.println("2. Wallet");
            System.out.println("3. Loyalty Points");
            System.out.print("Enter your choice: ");
            int paymentChoice = scanner.nextInt();
            scanner.nextLine();

            switch (paymentChoice) {
                case 1:
                    System.out.print("Enter Credit Card Number: ");
                    String cardNumber = scanner.nextLine();
                    System.out.print("Enter Card Holder Name: ");
                    String cardHolderName = scanner.nextLine();
                    paymentProcessor.setPaymentStrategy(new CreditCardPayment(cardNumber, cardHolderName));
                    paymentProcessor.processPayment(amount);
                    paymentSuccessful = true;
                    break;
                case 2:
                    System.out.print("Enter Wallet ID: ");
                    String walletID = scanner.nextLine();
                    paymentProcessor.setPaymentStrategy(new WalletPayment(walletID));
                    paymentProcessor.processPayment(amount);
                    paymentSuccessful = true;
                    break;
                case 3:
                    boolean isLoyaltyPointsSufficient = activeUser.redeemLoyaltyPoints(amount);
                    if (isLoyaltyPointsSufficient) {
                        paymentProcessor.setPaymentStrategy(new LoyaltyPointsPayment(activeUser));
                        paymentProcessor.processPayment(amount);
                        paymentSuccessful = true;
                    } else {
                        System.out.println("Please choose another payment method.");
                    }
                    break;
                default:
                    System.out.println("Invalid payment method. Please select a valid option.");
                    break;
            }
        }
        
        activeUser.addLoyaltyPoiints(100);
    }

    public String getDeliveryTimeWithFixedStart() {
        String userCountry = getUserCountry();
        if (userCountry == null) {
            System.out.println("Couldn't identify your country. Results will be not limited to your country.");
        }

        try {
            String fixedStartPlace = "Pizza Hut, Alvis Town Road, Wattala 11300, Sri Lanka";
            String fixedStartCoordinates = "6.9862699,79.8892128";

            System.out.println("From MEGA OnE: " + fixedStartPlace);

            String endPlace = null;
            List<String> endCoordinatesList = null;

            while (true) {
                System.out.print("Enter the delivery address: ");
                endPlace = scanner.nextLine();
                endCoordinatesList = getCoordinatesFromPlace(endPlace, userCountry);

                if (endCoordinatesList.isEmpty()) {
                    System.out.println("No places found in your country for the destination location. Please try again.");
                } else {
                    break;
                }
            }

            System.out.println("Select the correct destination place:");
            for (int i = 0; i < endCoordinatesList.size(); i++) {
                System.out.println((i + 1) + ". " + endCoordinatesList.get(i));
            }

            int endChoice = -1;
            while (endChoice < 1 || endChoice > endCoordinatesList.size()) {
                System.out.print("Enter the number of the correct destination place: ");

                while (!scanner.hasNextInt()) {
                    System.out.print("Invalid input. Please enter a valid number: ");
                    scanner.next();
                }

                endChoice = scanner.nextInt();
                scanner.nextLine();

                if (endChoice < 1 || endChoice > endCoordinatesList.size()) {
                    System.out.println("Invalid choice. Please enter a valid number between 1 and " + endCoordinatesList.size());
                }
            }

            String endCoordinates = endCoordinatesList.get(endChoice - 1).split(":")[1].trim();
            
            userDeliveryAddress = endCoordinatesList.get(endChoice - 1);

            if (endCoordinates == null) {
                System.out.println("Error retrieving coordinates. Please check the place name.");
                return null;
            }

            double deliveryTime = calculateDeliveryTime(fixedStartCoordinates, endCoordinates);

            if (deliveryTime != -1) {
                return formatDeliveryTime(deliveryTime);
            } else {
                return "Unable to calculate delivery time.";
            }

        } catch (Exception e) {
            e.printStackTrace();
            return "An error occurred while calculating the delivery time.";
        }
    }
    
    public void getDeliveryTime() {
        String userCountry = getUserCountry();
        if (userCountry == null) {
            System.out.println("Couldn't identify your country. Results will be not limited to your country.");
        }



        try {
            System.out.print("Enter the starting place name: ");
            String startPlace = scanner.nextLine();
            List<String> startCoordinatesList = getCoordinatesFromPlace(startPlace, userCountry);

            if (startCoordinatesList.isEmpty()) {
                System.out.println("No places found in your country for the starting location.");
                return;
            }
            
            System.out.println("Select the correct starting place:");
            for (int i = 0; i < startCoordinatesList.size(); i++) {
                System.out.println((i + 1) + ". " + startCoordinatesList.get(i));
            }
            
            System.out.print("Enter the number of the correct starting place: ");
            int startChoice = scanner.nextInt();
            scanner.nextLine();

            
            System.out.print("Enter the destination place name: ");
            String endPlace = scanner.nextLine();
            List<String> endCoordinatesList = getCoordinatesFromPlace(endPlace, userCountry);
            
            if (endCoordinatesList.isEmpty()) {
                System.out.println("No places found in your country for the destination location.");
                return;
            }
            System.out.println("Select the correct destination place:");
            for (int i = 0; i < endCoordinatesList.size(); i++) {
                System.out.println((i + 1) + ". " + endCoordinatesList.get(i));
            }
            System.out.print("Enter the number of the correct destination place: ");
            int endChoice = scanner.nextInt();
            scanner.nextLine();

            String startCoordinates = startCoordinatesList.get(startChoice - 1).split(":")[1].trim();
            String endCoordinates = endCoordinatesList.get(endChoice - 1).split(":")[1].trim();

            if (startCoordinates == null || endCoordinates == null) {
                System.out.println("Error retrieving coordinates. Please check the place names.");
                return;
            }

            double deliveryTime = calculateDeliveryTime(startCoordinates, endCoordinates);

            if (deliveryTime != -1) {
                String finalEstimatedDeliveryTime = formatDeliveryTime(deliveryTime);
                System.out.println("Delivery time: " + finalEstimatedDeliveryTime);
            } else {
                System.out.println("Unable to calculate delivery time.");
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void initiateSystem() {
        boolean exit = false;

        while (!exit) {
            displayMainMenu();
            System.out.print("Enter menu number: ");
            int choice = scanner.nextInt();
            scanner.nextLine();

            switch (choice) {
                case 1:
                    placeNewOrder();
                    break;
                case 2:
                    viewPizzaMenu();
                    break;
                case 3:
                    viewProfile();
                    break;
                case 4:
                    manageFavorites();
                    break;
                case 5:
                    viewOrderHistory();
                    break;
                case 6:
                    trackOrder();
                    break;
                case 7:
                    viewPromotions();
                    break;
                case 8:
                    provideFeedback();
                    break;
                case 9:
                    viewFeedback();
                    break;
                case 10:
                    displayTopRatedPizzasMenu();
                    break;
                case 11:
                    System.out.println("Thank you for visiting MEGA OnE Pizza! Goodbye!");
                    exit = true;
                    break;
                default:
                    System.out.println("Invalid option. Please try again.");
            }
        }
    }

    private void displayTopRatedPizzasMenu() {
        System.out.println("\n--- Top Rated Pizzas ---\n");

        List<Pizza> allPizzas = repository.getAllPizzas();
        List<Pizza> ratedPizzas = new ArrayList<>();

        for (Pizza pizza : allPizzas) {
            ratedPizzas.add(pizza);
        }

        ratedPizzas.sort((p1, p2) -> Double.compare(p2.getRating(), p1.getRating()));

        System.out.println("Top Rated Pizzas:");
        for (int i = 0; i < ratedPizzas.size(); i++) {
            Pizza pizza = ratedPizzas.get(i);
            double rating = pizza.getRating();
            System.out.printf("%d. %s - Rating: %.2f\n", (i + 1), pizza.getName(), rating);
        }

        System.out.println("\nOptions:");
        System.out.println("1. Order a pizza from this list");
        System.out.println("2. Return to main menu");
        System.out.print("Enter your choice: ");

        int choice = getValidInput(2);

        switch (choice) {
            case 1:
                orderPromotedPizza(ratedPizzas);
                break;
            case 2:
                return;
            default:
                System.out.println("Invalid choice. Please try again.");
        }
    }

    // New order placement
    
    private void placeNewOrder() {
        System.out.println("\n--- Place a New Order ---\n");
        
        System.out.println("Select Delivery Type:");
        System.out.println("1. Delivery");
        System.out.println("2. Pickup");
        System.out.print("Enter your choice: ");

        int deliveryTypeChoice = getValidInput(2);
        String deliveryType = "";
        switch (deliveryTypeChoice) {
            case 1:
                deliveryType = "Delivery";
                break;
            case 2:
                deliveryType = "Pickup";
                break;
            default:
                break;
        }

        String crust = getValidCrustChoice();
        String sauce = getValidSauceChoice();
        List<String> toppings = getValidToppingsChoice();
        String cheese = getValidCheeseChoice();
        String size = getValidSizeChoice();
        
        System.out.print("Enter a name for your custom pizza: ");
        String pizzaName = scanner.nextLine();

        
        double basePrice = 600;
        switch (size) {
            case "Small":
                basePrice += 200;
                break;
            case "Medium":
                basePrice += 1200;
                break;
            case "Large":
                basePrice += 4400;
                break;
            default:
                break;
        }

        basePrice += toppings.size() * 200;

        PizzaBuilder builder = new PizzaBuilder();
        Pizza customPizza = builder
                .setName(pizzaName)
                .setDescription("Custom Pizza")
                .setCrustType(crust)
                .setSauceType(sauce)
                .setsize(size)
                .addTopping(toppings)
                .setBasePrice(basePrice)
                .build();

        System.out.println("\nYour custom pizza has been created:");
        System.out.println(customPizza);

         System.out.print("Enter the quantity of this pizza you would like to order: ");
         int quantity = getValidInput(10);
         double totalPrice = customPizza.calculatePrice() * quantity;

        System.out.print("Would you like to save this pizza to your favorites? (yes/no): ");
        String saveToFavorites = scanner.nextLine();

        if (saveToFavorites.equalsIgnoreCase("yes")) {
            activeUser.addFavoritePizza(customPizza);
            System.out.println("Pizza saved to favorites.");
        }

        System.out.println("Would you like to confirm this order? (yes/no): ");
        String confirm = scanner.nextLine();

        if (confirm.equalsIgnoreCase("yes")) {
            String estimatedDeliveryTime = "";
            if (deliveryType.equals("Delivery")) {
                estimatedDeliveryTime = getDeliveryTimeWithFixedStart();
                if (userDeliveryAddress == null || userDeliveryAddress.isEmpty()) {
                    System.out.println("Error: Invalid delivery address.");
                    return;
                }
            } else {
                userDeliveryAddress = "Pickup";
                estimatedDeliveryTime = "0 minutes";
            }

            acceptPayment(totalPrice);

            Order newOrder = deliveryType.equals("Delivery") ? new Order(userDeliveryAddress, estimatedDeliveryTime) : new Order(1);
            
            if (newOrder == null) {
                System.out.println("Order could not be created.");
                return;
            }

            newOrder.registerObserver(activeUser);

            PlaceOrderCommand placeOrderCommand = new PlaceOrderCommand(newOrder, repository);

            CommandManager commnadManager = new CommandManager();
            commnadManager.addCommand(placeOrderCommand);
            commnadManager.executeCommands();

            System.out.println("Your order has been placed successfully!");
            System.out.println("\nPreparation time: 5 minutes");
            System.out.println("Estimated delivery time: " + estimatedDeliveryTime);
        
            activeUser.addLoyaltyPoiints(100);

            scheduleOrderTransitions(newOrder, estimatedDeliveryTime);

        } else {
            System.out.println("Order cancelled.");
        }
    }
    
    // Delivery tracking section
    
    private void scheduleOrderTransitions(Order order, String estimatedDeliveryTime) {
        Timer timer = new Timer();

        double deliveryTimeInMinutes = 0.0;
        try {
            String numericPart = estimatedDeliveryTime.split(" ")[0];
            deliveryTimeInMinutes = Double.parseDouble(numericPart);
        } catch (NumberFormatException | ArrayIndexOutOfBoundsException e) {
            System.out.println("Error parsing delivery time. Defaulting to 30 minutes.");
            deliveryTimeInMinutes = 30.0;
        }

        TimerTask preparationTask = new TimerTask() {
            @Override
            public void run() {
                order.setStatus("In Preparation");
                order.nextState();
            }
        };

        TimerTask deliveryTask = new TimerTask() {
            @Override
            public void run() {
                order.setStatus("Out for Delivery");
                order.nextState();
            }
        };

        TimerTask deliveredTask = new TimerTask() {
            @Override
            public void run() {
                order.setStatus("Delivered");
                order.nextState();
                timer.cancel();
                
                requestFeedback(order);
            }
        };

        timer.schedule(preparationTask, 0);
        timer.schedule(deliveryTask, 300000);
        timer.schedule(deliveredTask, 300000 + (int) (deliveryTimeInMinutes * 60000));
    }

    private void requestFeedback(Order order) {
        System.out.println("\nYour order has been delivered! Please provide feedback.");

        System.out.print("Enter your rating (1 to 5): ");
        double rating = scanner.nextDouble();
        scanner.nextLine();

        System.out.print("Enter your comments: ");
        String comments = scanner.nextLine();

        Feedback feedback = new Feedback(activeUser.getUserID(), order.getOrderID(), rating, comments);
        ProvideFeedbackCommand feedbackCommand = new ProvideFeedbackCommand(feedback, repository);

        Pizza pizzaToUpdate = repository.getPizza(order.getOrderID());
        if (pizzaToUpdate != null) {
            pizzaToUpdate.setRating(feedback.getRating());
            repository.updatePizza(pizzaToUpdate);
        }

        CommandManager commandManager = new CommandManager();
        commandManager.addCommand(feedbackCommand);
        commandManager.executeCommands();
    }
    
    private void updateOrderInRepository(Order order) {
        int orderID = order.getOrderID();
        repository.removeOrder(orderID);
        repository.addOrder(order);
    }
    
    private long parseDeliveryTime(String time) {
        if (time == null || time.isEmpty()) {
            return 0;
        }

        Pattern minutesPattern = Pattern.compile("(\\d+\\.?\\d*)\\s+minutes");
        Pattern hoursPattern = Pattern.compile("(\\d+\\.?\\d*)\\s+hours");
        Pattern daysPattern = Pattern.compile("(\\d+\\.?\\d*)\\s+days");

        Matcher minutesMatcher = minutesPattern.matcher(time);
        Matcher hoursMatcher = hoursPattern.matcher(time);
        Matcher daysMatcher = daysPattern.matcher(time);

        if (minutesMatcher.find()) {
            return (long) (Double.parseDouble(minutesMatcher.group(1)) * 60 * 1000);
        } else if (hoursMatcher.find()) {
            return (long) (Double.parseDouble(hoursMatcher.group(1)) * 60 * 60 * 1000);
        } else if (daysMatcher.find()) {
            return (long) (Double.parseDouble(daysMatcher.group(1)) * 24 * 60 * 60 * 1000);
        } else {
            System.out.println("Cannot parse delivery time: " + time);
            return 0;
        }
    }

    private String getValidCrustChoice() {
        String crust = "";
        boolean valid = false;

        while (!valid) {
            System.out.println("\nSelect Crust:");
            System.out.println("1. Thin");
            System.out.println("2. Thick");
            System.out.println("3. Whole Wheat");
            System.out.print("Enter your choice: ");

            int crustChoice = getValidInput(3);
            switch (crustChoice) {
                case 1:
                    crust = "Thin";
                    valid = true;
                    break;
                case 2:
                    crust = "Thick";
                    valid = true;
                    break;
                case 3:
                    crust = "Whole Wheat";
                    valid = true;
                    break;
                default:
                    break;
            }
        }
        return crust;
    }

    private String getValidSauceChoice() {
        String sauce = "";
        boolean valid = false;

        while (!valid) {
            System.out.println("\nSelect Sauce:");
            System.out.println("1. Tomato Basil");
            System.out.println("2. Pesto");
            System.out.println("3. White Garlic");
            System.out.print("Enter your choice: ");

            int sauceChoice = getValidInput(3);
            switch (sauceChoice) {
                case 1:
                    sauce = "Tomato Basil";
                    valid = true;
                    break;
                case 2:
                    sauce = "Pesto";
                    valid = true;
                    break;
                case 3:
                    sauce = "White Garlic";
                    valid = true;
                    break;
                default:
                    break;
            }
        }
        return sauce;
    }

    private List<String> getValidToppingsChoice() {
        List<String> toppings = new ArrayList<>();
        boolean valid = false;

        while (!valid) {
            System.out.println("\nSelect Toppings (Enter numbers separated by commas, e.g., 1,2,3):");
            System.out.println("1. Mushrooms");
            System.out.println("2. Olives");
            System.out.println("3. Pepperoni");
            System.out.println("4. Spinach");
            System.out.print("Enter your choices: ");

            String[] toppingChoices = scanner.nextLine().split(",");
            valid = true;

            if (toppingChoices.length < minToppings || toppingChoices.length > maxToppings) {
                System.out.println("Please enter a valid number of toppings between " + minToppings + " and " + maxToppings);
                valid = false;
                continue;
            }

            List<String> tempToppings = new ArrayList<>();
            for (String choice : toppingChoices) {
                try {
                    int choiceNum = Integer.parseInt(choice.trim());
                    String toppingName = "";
                    switch (choiceNum) {
                        case 1:
                            toppingName = "Mushrooms";
                            break;
                        case 2:
                            toppingName = "Olives";
                            break;
                        case 3:
                            toppingName = "Pepperoni";
                            break;
                        case 4:
                            toppingName = "Spinach";
                            break;
                        default:
                            valid = false;
                            System.out.println("Invalid topping choice: " + choice);
                            break;
                    }

                    if (valid) {
                        if (tempToppings.contains(toppingName)) {
                            System.out.println("Topping " + toppingName + " is already added");
                            valid = false;
                            break;
                        } else {
                            tempToppings.add(toppingName);
                        }
                    } else {
                        break;
                    }

                } catch (NumberFormatException e) {
                    valid = false;
                    System.out.println("Invalid topping choice: " + choice);
                    break;
                }
            }

            if (valid) {
                toppings.addAll(tempToppings);
            } else {
                System.out.println("Please enter valid topping choices.");
            }
        }
        return toppings;
    }

    private String getValidCheeseChoice() {
        String cheese = "";
        boolean valid = false;

        while (!valid) {
            System.out.println("\nSelect Cheese:");
            System.out.println("1. Mozzarella");
            System.out.println("2. Cheddar");
            System.out.println("3. Vegan");
            System.out.print("Enter your choice: ");

            int cheeseChoice = getValidInput(3);
            switch (cheeseChoice) {
                case 1:
                    cheese = "Mozzarella";
                    valid = true;
                    break;
                case 2:
                    cheese = "Cheddar";
                    valid = true;
                    break;
                case 3:
                    cheese = "Vegan";
                    valid = true;
                    break;
                default:
                    break;
            }
        }
        return cheese;
    }

    private String getValidSizeChoice() {
        String size = "";
        boolean valid = false;

        while (!valid) {
            System.out.println("\nSelect Size:");
            System.out.println("1. Small");
            System.out.println("2. Medium");
            System.out.println("3. Large");
            System.out.print("Enter your choice: ");

            int sizeChoice = getValidInput(3);
            switch (sizeChoice) {
                case 1:
                    size = "Small";
                    valid = true;
                    break;
                case 2:
                    size = "Medium";
                    valid = true;
                    break;
                case 3:
                    size = "Large";
                    valid = true;
                    break;
                default:
                    break;
            }
        }
        return size;
    }

    private int getValidInput(int maxChoice) {
        int choice = -1;
        while (choice < 1 || choice > maxChoice) {
            while (!scanner.hasNextInt()) {
                System.out.print("Invalid input. Please enter a valid number: ");
                scanner.next();
            }
           try {
                choice = scanner.nextInt();
           } catch (Exception e) {
               choice = -1;
               scanner.next();
           }
           
           scanner.nextLine();
            if (choice < 1 || choice > maxChoice) {
                System.out.println("Invalid option. Please try again.");
            }
        }
        return choice;
    }

    private void viewPizzaMenu() {
        System.out.println("\n--- View Pizza Menu ---\n");

        List<Pizza> allPizzas = repository.getAllPizzas();

        if (allPizzas.isEmpty()) {
            System.out.println("No pizzas found in the menu.");
        } else {
            while (true) {
                for (Pizza pizza : allPizzas) {
                    System.out.println(pizza);
                    System.out.println("--------------------------");
                }

                System.out.println("Options:");
                System.out.println("1. Order a pizza");
                System.out.println("2. Add a pizza to favorites");
                System.out.println("3. Return to main menu");
                System.out.print("Enter your choice: ");

                int choice = getValidInput(3);

                switch (choice) {
                    case 1:
                        orderPizzaWithCustomization(allPizzas);
                        break;

                    case 2:
                        addPizzaToFavorites(allPizzas);
                        break;

                    case 3:
                        return;

                    default:
                        System.out.println("Invalid choice. Please try again.");
                }
            }
        }
    }

    private void orderPizzaWithCustomization(List<Pizza> allPizzas) {
        System.out.print("Enter the ID of the pizza you'd like to order: ");
        int pizzaID = getValidInput(allPizzas.size());

        Pizza selectedPizza = repository.getPizza(pizzaID);
        if (selectedPizza == null) {
            System.out.println("Invalid pizza ID. Please try again.");
            return;
        }

        System.out.println("\nSelected Pizza:");
        System.out.println(selectedPizza);

        System.out.println("\nWhat would you like to do?");
        System.out.println("1. Order as-is");
        System.out.println("2. Customize and order");
        System.out.print("Enter your choice: ");
        int choice = getValidInput(2);

        switch (choice) {
            case 1:
                placeNewOrder(selectedPizza);
                break;

            case 2:
                customizePizza(selectedPizza);
                break;

            default:
                System.out.println("Invalid choice.");
                return;
        }
    }
    
    private void customizePizza(Pizza selectedPizza) {
        CustomizedPizza customizedPizza = new CustomizedPizza(selectedPizza);

        System.out.println("\nCustomize your pizza:");

        CustomizationHandler crustHandler = new CrustHandler();
        CustomizationHandler sauceHandler = new SauceHandler();
        CustomizationHandler toppingHandler = new ToppingHandler();
        CustomizationHandler extraFeatureHandler = new ExtraFeatureHandler();

        crustHandler.setNextHandler(sauceHandler);
        sauceHandler.setNextHandler(toppingHandler);
        toppingHandler.setNextHandler(extraFeatureHandler);

        System.out.println("\nSelect Crust:");
        System.out.println("1. Thin (Default)");
        System.out.println("2. Thick (+Rs.200)");
        System.out.println("3. Whole Wheat (+Rs.300)");
        System.out.print("Enter your choice: ");
        int crustChoice = getValidInput(3);

        if (crustChoice == 2) {
            crustHandler.handleRequest(customizedPizza, "Crust:Thick");
        } else if (crustChoice == 3) {
            crustHandler.handleRequest(customizedPizza, "Crust:Whole Wheat");
        }

        System.out.println("\nSelect Sauce:");
        System.out.println("1. Tomato Basil (Default)");
        System.out.println("2. Pesto (+Rs.100)");
        System.out.println("3. White Garlic (+Rs.150)");
        System.out.print("Enter your choice: ");
        int sauceChoice = getValidInput(3);

        if (sauceChoice == 2) {
            sauceHandler.handleRequest(customizedPizza, "Sauce:Pesto");
        } else if (sauceChoice == 3) {
            sauceHandler.handleRequest(customizedPizza, "Sauce:White Garlic");
        }

        System.out.println("\nAdd Toppings (Type 'done' to finish):");
        String[] availableToppings = {"Mushrooms", "Olives", "Pepperoni", "Spinach"};
        while (true) {
            System.out.println("1. Mushrooms (+Rs.100)");
            System.out.println("2. Olives (+Rs.100)");
            System.out.println("3. Pepperoni (+Rs.150)");
            System.out.println("4. Spinach (+Rs.100)");
            System.out.print("Enter your choice (or type 'done'): ");
            String toppingInput = scanner.nextLine();
            if (toppingInput.equalsIgnoreCase("done")) {
                break;
            }

            try {
                int toppingChoice = Integer.parseInt(toppingInput);
                if (toppingChoice >= 1 && toppingChoice <= availableToppings.length) {
                    toppingHandler.handleRequest(customizedPizza, "Topping:" + availableToppings[toppingChoice - 1]);
                } else {
                    System.out.println("Invalid choice. Please try again.");
                }
            } catch (NumberFormatException e) {
                System.out.println("Invalid input. Please enter a number.");
            }
        }
        
        System.out.println("\nAdd Special Features:");
        while (true) {
            System.out.println("1. Extra Cheese (+Rs.100)");
            System.out.println("2. Extra Pepperoni (+Rs.150)");
            System.out.println("3. Special Packaging (+Rs.50)");
            System.out.println("4. Done");
            System.out.print("Enter your choice: ");
            int featureChoice = getValidInput(4);

            switch (featureChoice) {
                case 1:
                    extraFeatureHandler.handleRequest(customizedPizza, "Extra:Cheese");
                    break;
                case 2:
                    extraFeatureHandler.handleRequest(customizedPizza, "Extra:Pepperoni");
                    break;
                case 3:
                    extraFeatureHandler.handleRequest(customizedPizza, "Extra:Packaging");
                    break;
                case 4:
                    System.out.println("\nFinal Customized Pizza:");
                    System.out.println(customizedPizza);
                    placeNewOrder(customizedPizza);
                    return;
                default:
                    System.out.println("Invalid choice. Please try again.");
            }
        }
    }

    private void addPizzaToFavorites(List<Pizza> allPizzas) {
        System.out.print("Enter the ID of the pizza you'd like to add to your favorites: ");
        int pizzaID = getValidInput(allPizzas.size());

        Pizza selectedPizza = repository.getPizza(pizzaID);
        if (selectedPizza == null) {
            System.out.println("Invalid pizza ID. Please try again.");
            return;
        }

        activeUser.addFavoritePizza(selectedPizza);
        System.out.println("Pizza added to favorites successfully.");
    }
    
    private void placeNewOrder(Pizza pizza) {
        System.out.println("\nPlacing your order...");

        System.out.print("Enter the quantity of this pizza you would like to order: ");
        int quantity = getValidInput(10);
        double totalPrice = pizza.calculatePrice() * quantity;

        String estimatedDeliveryTime = getDeliveryTimeWithFixedStart();
        if (userDeliveryAddress == null || userDeliveryAddress.isEmpty()) {
            System.out.println("Error: Invalid delivery address.");
            return;
        }

        acceptPayment(totalPrice);

        Order newOrder = new Order(userDeliveryAddress, estimatedDeliveryTime);
        newOrder.registerObserver(activeUser);

        PlaceOrderCommand placeOrderCommand = new PlaceOrderCommand(newOrder, repository);

        CommandManager commandManager = new CommandManager();
        commandManager.addCommand(placeOrderCommand);
        commandManager.executeCommands();

        System.out.println("Your order has been placed successfully!");
        System.out.println("Preparation time: 5 minutes");
        System.out.println("Estimated delivery time: " + estimatedDeliveryTime);
        
        activeUser.addLoyaltyPoiints(100);

        scheduleOrderTransitions(newOrder, estimatedDeliveryTime);
    }



    private void viewProfile() {
        System.out.println("\n--- My Profile ---\n");
        if (activeUser != null) {
            System.out.println("Your ID: " + activeUser.getUserID());
            System.out.println("Name: " + activeUser.getName());
            System.out.println("Email: " + activeUser.getEmail());
            System.out.println("Phone Number: " + activeUser.getPhoneNumber());
            System.out.println("Loyalty Points: " + activeUser.getLoyaltyPoints());
        } else {
            System.out.println("No user profile found.");
        }
    }

    
    // Favorites pizza management
    
    private void manageFavorites() {
        System.out.println("\n--- My Favorites ---\n");

        if (activeUser == null || activeUser.getFavorites().isEmpty()) {
            System.out.println("You have no favorite pizzas saved.");
            return;
        }

        System.out.println("Your favorite pizzas:");
        for (Pizza pizza : activeUser.getFavorites()) {
            System.out.println(pizza);
            System.out.println("--------------------------");
        }

        System.out.println("Options:");
        System.out.println("1. Order a favorite pizza");
        System.out.println("2. Remove a pizza from favorites");
        System.out.println("3. Return to main menu");
        System.out.print("Enter your choice: ");

        int choice = getValidInput(3);

        switch (choice) {
            case 1:
                orderFavoritePizza();
                break;

            case 2:
                removePizzaFromFavorites();
                break;

            case 3:
                return;

            default:
                System.out.println("Invalid choice. Please try again.");
        }
    }

    private void orderFavoritePizza() {
        if (activeUser == null || activeUser.getFavorites().isEmpty()) {
            System.out.println("You have no favorite pizzas to order.");
            return;
        }

        System.out.println("Enter the ID of the favorite pizza you'd like to order: ");
        for (int i = 0; i < activeUser.getFavorites().size(); i++) {
            System.out.println((i + 1) + ". " + activeUser.getFavorites().get(i).getName());
        }

        int pizzaChoice = getValidInput(activeUser.getFavorites().size());
        Pizza selectedPizza = activeUser.getFavorites().get(pizzaChoice - 1);

        if (selectedPizza == null) {
            System.out.println("Invalid pizza ID. Please try again.");
            return;
        }
        
        placeNewOrder(selectedPizza);
    }
    
    private void removePizzaFromFavorites() {
        if (activeUser == null || activeUser.getFavorites().isEmpty()) {
            System.out.println("You have no favorite pizzas to remove.");
            return;
        }

        System.out.print("Enter the ID of the favorite pizza you'd like to remove: ");
        for (int i = 0; i < activeUser.getFavorites().size(); i++) {
            System.out.println((i + 1) + ". " + activeUser.getFavorites().get(i).getName());
        }

        int pizzaChoice = getValidInput(activeUser.getFavorites().size());
        Pizza selectedPizza = activeUser.getFavorites().get(pizzaChoice - 1);

        if (selectedPizza == null) {
            System.out.println("Invalid pizza ID. Please try again.");
            return;
        }

        activeUser.removeFavoritePizza(selectedPizza.getPizzaID());
        System.out.println("Pizza removed from favorites successfully.");
    }

    private void viewOrderHistory() {
        System.out.println("\n--- Order History ---\n");
        
        List<Order> allOrders = repository.getAllOrders();

        if (allOrders.isEmpty()) {
            System.out.println("No orders found in your order history.");
        } else {
            for (Order order : allOrders) {
                System.out.println(order);
            }
        }
    }

    private void trackOrder() {
        System.out.println("\n--- Track Order ---");
        
        List<Order> allOrders = repository.getAllOrders();

        if (allOrders.isEmpty()) {
            System.out.println("No orders found in your order history.");
        } else {
            for (Order order : allOrders) {
                System.out.println(order);
            }
            
            System.out.print("Enter the order ID to track: ");
            int orderIDToTrack = scanner.nextInt();
            scanner.nextLine();
            
            Order order = repository.getOrder(orderIDToTrack);
            
            if (order == null) {
                System.out.println("Order not found with ID: " + orderIDToTrack);
                return;
            }
            
            System.out.println("Tracking order: " + order.getOrderID());
            trackOrderHelper(order);
            System.out.println("Current order status: " + order.getStateName());
        }
    }
    
    private void trackOrderHelper(Order order) {
        System.out.println("Tracking the order...");
        
        if(order.getStateName().equals("Placed")) {
            System.out.println("\nOrder is " + order.getStateName());
        } else if (order.getStateName().equals("In Preparation")) {
            System.out.println("\nOrder is " + order.getStateName());
        } else if (order.getStateName().equals("Out for Delivery")) {
           System.out.println("\nOrder is " + order.getStateName());
        } else {
          System.out.println("\nOrder is already " + order.getStateName());
        }
    }

    
    // Promotions management
    
    private void viewPromotions() {
        System.out.println("\n--- Seasonal Specials and Promotions ---\n");

        List<Pizza> allPizzas = repository.getAllPizzas();
        List<Pizza> pizzasWithPromotions = promotionManager.getPizzasWithPromotions(allPizzas);

        if (pizzasWithPromotions.isEmpty()) {
            System.out.println("No promotions available at the moment.");
            return;
        }

        while (true) {
            System.out.println("\nPizzas with Promotions:");
            int index = 1;
            for (Pizza pizza : pizzasWithPromotions) {
                System.out.println(index + ". " + pizza);
                System.out.println("Promotions Applied:");
                for (PromotionStrategy promotion : promotionManager.getActivePromotions()) {
                    if (promotion.isEligible(pizza)) {
                        System.out.println(" - " + promotion.getPromotionDetails());
                    }
                }
                System.out.println("--------------------------");
                index++;
            }

            System.out.println("\nOptions:");
            System.out.println("1. Order a pizza from this list");
            System.out.println("2. Return to main menu");
            System.out.print("Enter your choice: ");

            int choice = getValidInput(2);

            switch (choice) {
                case 1:
                    orderPromotedPizza(pizzasWithPromotions);
                    return;
                case 2:
                    return;
                default:
                    System.out.println("Invalid choice. Please try again.");
            }
        }
    }
    
    private void orderPromotedPizza(List<Pizza> pizzasWithPromotions) {
        System.out.print("\nEnter the number of the pizza you'd like to order: ");
        int pizzaIndex = getValidInput(pizzasWithPromotions.size()) - 1;

        Pizza selectedPizza = pizzasWithPromotions.get(pizzaIndex);

        System.out.println("\nSelected Pizza:");
        System.out.println(selectedPizza);

        System.out.println("\nWhat would you like to do?");
        System.out.println("1. Order as-is");
        System.out.println("2. Customize and order");
        System.out.print("Enter your choice: ");
        int choice = getValidInput(2);

        switch (choice) {
            case 1:
                placeNewOrderWithPromotion(selectedPizza);
                break;
            case 2:
                customizePizzaWithPromotion(selectedPizza);
                break;
            default:
                System.out.println("Invalid choice.");
        }
    }
    
    private void placeNewOrderWithPromotion(Pizza pizza) {
        System.out.println("\nPlacing your order...");
        
        System.out.print("Enter the quantity of this pizza you would like to order: ");
        int quantity = getValidInput(10);

        double finalPrice = pizza.getBasePrice();
        for (PromotionStrategy promotion : promotionManager.getActivePromotions()) {
            if (promotion.isEligible(pizza)) {
                finalPrice = promotion.applyDiscount(pizza);
                System.out.println("Promotion applied: " + promotion.getPromotionDetails());
            }
        }

        System.out.println("Final Price after Promotions: Rs." + finalPrice);
        double totalPrice = finalPrice * quantity;

        acceptPayment(totalPrice);

        String estimatedDeliveryTime = getDeliveryTimeWithFixedStart();
        Order newOrder = new Order(userDeliveryAddress, estimatedDeliveryTime);
        repository.addOrder(newOrder);
        
        PlaceOrderCommand placeOrderCommand = new PlaceOrderCommand(newOrder, repository);

        CommandManager commandManager = new CommandManager();
        commandManager.addCommand(placeOrderCommand);
        commandManager.executeCommands();

        scheduleOrderTransitions(newOrder, estimatedDeliveryTime);
        System.out.println("Your order has been placed successfully!");
        return;
        
    }
    
    private void customizePizzaWithPromotion(Pizza pizza) {
        CustomizedPizza customizedPizza = new CustomizedPizza(pizza);
        customizePizza(customizedPizza);

        System.out.print("Enter the quantity of this pizza you would like to order: ");
        int quantity = getValidInput(10);

        double finalPrice = customizedPizza.calculatePrice();
        for (PromotionStrategy promotion : promotionManager.getActivePromotions()) {
            if (promotion.isEligible(customizedPizza)) {
                finalPrice = promotion.applyDiscount(customizedPizza);
                System.out.println("Promotion applied: " + promotion.getPromotionDetails());
            }
        }

        System.out.println("Final Price after Promotions and Customization: Rs." + finalPrice);
        double totalPrice = finalPrice * quantity;
        acceptPayment(totalPrice);

        String estimatedDeliveryTime = getDeliveryTimeWithFixedStart();
        Order newOrder = new Order(userDeliveryAddress, estimatedDeliveryTime);
        newOrder.registerObserver(activeUser);

        PlaceOrderCommand placeOrderCommand = new PlaceOrderCommand(newOrder, repository);

        CommandManager commandManager = new CommandManager();
        commandManager.addCommand(placeOrderCommand);
        commandManager.executeCommands();

        scheduleOrderTransitions(newOrder, estimatedDeliveryTime);
        System.out.println("Your order has been placed successfully!");
        return;
    }
    
    private void initializePromotions() {
        promotionManager = new PromotionManager();
        promotionManager.addPromotion(new ToppingDiscountPromotion("Mushrooms", 100));
        promotionManager.addPromotion(new SizeDiscountPromotion("Large", 400));
    }

    // Feedback management
    
    private void provideFeedback() {
        System.out.println("\n--- Provide Feedback ---");

        List<Order> allOrders = repository.getAllOrders();

        if (allOrders.isEmpty()) {
            System.out.println("No orders found. Feedback cannot be submitted.");
            return;
        }

        System.out.println("Select an order to provide feedback for:");
        for (Order order : allOrders) {
            System.out.println(order.getOrderID() + ". " + order);
        }

        System.out.print("Enter the order ID: ");
        int orderID = getValidInput(allOrders.size());

        Order selectedOrder = repository.getOrder(orderID);
        if (selectedOrder == null) {
            System.out.println("Invalid order ID. Feedback submission canceled.");
            return;
        }

        System.out.print("Enter your rating (1 to 5): ");
        double rating = scanner.nextDouble();
        
        // Clear the buffer as usual
        scanner.nextLine();

        System.out.print("Enter your comments: ");
        String comments = scanner.nextLine();

        Feedback feedback = new Feedback(activeUser.getUserID(), selectedOrder.getOrderID(), rating, comments);
        ProvideFeedbackCommand feedbackCommand = new ProvideFeedbackCommand(feedback, repository);
        
        Pizza pizzaToUpdate = repository.getPizza(selectedOrder.getOrderID());
        pizzaToUpdate.setRating(feedback.getRating());
        repository.updatePizza(pizzaToUpdate);

        CommandManager commandManager = new CommandManager();
        commandManager.addCommand(feedbackCommand);
        commandManager.executeCommands();
    }

    private void viewFeedback() {
        System.out.println("\n--- View Feedback ---");

        List<Feedback> allFeedbacks = repository.getAllFeedbacks();
        if (allFeedbacks.isEmpty()) {
            System.out.println("No feedback has been submitted yet.");
            return;
        }

        System.out.println("Feedback List:");
        for (Feedback feedback : allFeedbacks) {
            System.out.println(feedback);
        }
    }
    
    public static void main(String[] args) {
        megaOne.initializePromotions();
        megaOne.pizzaFromMEGAOnE();
        megaOne.userCreation();
        megaOne.initiateSystem();
    }
}











































CustomizedPizza class,


package Components;

import java.util.List;

public class CustomizedPizza extends Pizza {
    private double extraCost;

    public CustomizedPizza(Pizza basePizza) {
        super(basePizza.getName(), basePizza.getDescription(), basePizza.getCrustType(),
              basePizza.getSauceType(), basePizza.getSize(), basePizza.getToppings(),
              basePizza.getBasePrice(), basePizza.getRating());
        this.extraCost = 0.0;
    }

    public void addCustomization(String customization, double cost) {
        setDescription(getDescription() + ", " + customization);
        this.extraCost += cost;
    }

    @Override
    public double calculatePrice() {
        return super.calculatePrice() + extraCost;
    }

    @Override
    public String toString() {
        return super.toString() + "\nExtra Cost: Rs." + extraCost + "\n";
    }
}













































DeliveryEstimator class,

package External;

import org.json.JSONObject;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import org.json.JSONArray;

public class DeliveryEstimator {
    private static final String openCageAPI = "cf28143f3cbd45ccb37c39b0ee203432";
    private static final String apiKey = "5b3ce3597851110001cf6248c8e8e61d3cdd4603adf6d4aadc428743";
    private static final String url = "https://api.openrouteservice.org/v2/directions/driving-car/json";

    
    public static String getUserCountry() {
        try {
            URL url = new URL("http://ipinfo.io/json");
            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));
            StringBuilder response = new StringBuilder();
            String inputLine;
            while ((inputLine = in.readLine()) != null) {
                response.append(inputLine);
            }
            in.close();

            // Structure of the result
            // System.out.println("Raw response from ipinfo.io: " + response.toString());

            JSONObject jsonResponse = new JSONObject(response.toString());
            return jsonResponse.getString("country");
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }


    
    public static List<String> getCoordinatesFromPlace(String placeName, String userCountry) throws Exception {
        String encodedPlaceName = URLEncoder.encode(placeName, StandardCharsets.UTF_8.toString());
        String urlString = "https://api.opencagedata.com/geocode/v1/json?q=" + encodedPlaceName + "&key=" + openCageAPI;
        URL url = new URL(urlString);
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
        connection.setRequestMethod("GET");

        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
        StringBuilder response = new StringBuilder();
        String inputLine;
        while ((inputLine = in.readLine()) != null) {
            response.append(inputLine);
        }
        in.close();

        JSONObject jsonResponse = new JSONObject(response.toString());
        List<String> placeCoordinates = new ArrayList<>();

        if (jsonResponse.has("results") && jsonResponse.getJSONArray("results").length() > 0) {
            JSONArray results = jsonResponse.getJSONArray("results");
            
            for (int i = 0; i < Math.min(5, results.length()); i++) {
                JSONObject result = results.getJSONObject(i);
                String formattedPlace = result.getString("formatted");
                JSONObject components = result.getJSONObject("components");
                String country = components.optString("country_code").toUpperCase();

                if (country.equals(userCountry)) {
                    JSONObject geometry = result.getJSONObject("geometry");
                    double lat = geometry.getDouble("lat");
                    double lng = geometry.getDouble("lng");
                    placeCoordinates.add(formattedPlace + ": " + lat + "," + lng);
                }
            }
        } else {
            System.out.println("Could not find coordinates for: " + placeName);
        }

        return placeCoordinates;
    }



    public static double calculateDeliveryTime(String startCoordinates, String endCoordinates) {
        try {
            HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -> true);
            TrustManager[] trustAllCerts = new TrustManager[] {
                new X509TrustManager() {
                    public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                        return null;
                    }
                    public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {
                    }
                    public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {
                    }
                }
            };
            
            SSLContext sslContext = SSLContext.getInstance("SSL");
            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());

            JSONObject payload = new JSONObject();
            payload.put("coordinates", new double[][] {
                parseCoordinates(startCoordinates),
                parseCoordinates(endCoordinates)
            });

            JSONObject jsonResponse = fetchRouteData(payload);

            if (jsonResponse.has("routes") && jsonResponse.getJSONArray("routes").length() > 0) {
                JSONObject route = jsonResponse.getJSONArray("routes").getJSONObject(0);

                if (route.has("summary")) {
                    JSONObject summary = route.getJSONObject("summary");

                    double distanceInMeters = summary.getDouble("distance");

                    double averageSpeed = 40.0; // avg speed - km/h
                    double distanceInKilometers = distanceInMeters / 1000.0;
                    double timeInHours = distanceInKilometers / averageSpeed;
                    double timeInMinutes = timeInHours * 60;

                    return timeInMinutes;
                } else {
                    System.out.println("Error: 'summary' field is missing in the route.");
                }
            } else {
                System.out.println("Error: No routes found in the API response.");
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

        return -1;
    }

    private static JSONObject fetchRouteData(JSONObject payload) throws Exception {
        HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();
        connection.setRequestMethod("POST");
        connection.setRequestProperty("Authorization", apiKey);
        connection.setRequestProperty("Content-Type", "application/json");
        connection.setRequestProperty("Accept", "application/json");
        connection.setDoOutput(true);

        try (OutputStream os = connection.getOutputStream()) {
            os.write(payload.toString().getBytes());
            os.flush();
        }

        int responseCode = connection.getResponseCode();
        if (responseCode != 200) {
            throw new RuntimeException("Failed API call with status: " + responseCode);
        }

        try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {
            StringBuilder response = new StringBuilder();
            String inputLine;
            while ((inputLine = in.readLine()) != null) {
                response.append(inputLine);
            }
            return new JSONObject(response.toString());
        }
    }

    private static double[] parseCoordinates(String coordinates) {
        try {
            String[] parts = coordinates.split(",");
            if (parts.length != 2) {
                throw new IllegalArgumentException("Invalid coordinate format. Expected 'latitude,longitude'.");
            }
            return new double[] { Double.parseDouble(parts[1]), Double.parseDouble(parts[0]) };
        } catch (Exception e) {
            System.err.println("Invalid coordinates format: " + e.getMessage());
            throw e;
        }
    }

}






















DataRepository class,


package Components;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DataRepository {

    // Local variables
    private final Map<Integer, Pizza> pizzas;
    private final Map<Integer, Order> orders;
    private final Map<Integer, User> users;
    private final Map<Integer, Feedback> feedbacks;
    private final Map<Integer, Promotion> promotions;
    private final Map<Integer, Payment> payments;

    // Constructor
    public DataRepository() {
        this.pizzas = new HashMap<>();
        this.orders = new HashMap<>();
        this.users = new HashMap<>();
        this.feedbacks = new HashMap<>();
        this.promotions = new HashMap<>();
        this.payments = new HashMap<>();
    }

    // --- Pizza Management ---
    
    public void addPizza(Pizza pizza) {
        pizzas.put(pizza.getPizzaID(), pizza);
    }
    
    public void updatePizza(Pizza pizza) {
        pizzas.put(pizza.getPizzaID(), pizza);
    }

    public Pizza getPizza(int pizzaID) {
        return pizzas.get(pizzaID);
    }

    public List<Pizza> getAllPizzas() {
        return new ArrayList<>(pizzas.values());
    }

    public void removePizza(int pizzaID) {
        pizzas.remove(pizzaID);
    }

    // --- Order Management ---
    public void addOrder(Order order) {
        orders.put(order.getOrderID(), order);
    }

    public Order getOrder(int orderID) {
        return orders.get(orderID);
    }

    public List<Order> getAllOrders() {
        return new ArrayList<>(orders.values());
    }

    public void removeOrder(int orderID) {
        orders.remove(orderID);
    }

    // --- User Management ---
    public void addUser(User user) {
        users.put(user.getUserID(), user);
    }

    public User getUser(int userID) {
        return users.get(userID);
    }

    public List<User> getAllUsers() {
        return new ArrayList<>(users.values());
    }

    public void removeUser(int userID) {
        users.remove(userID);
    }

    public void addFeedback(Feedback feedback) {
        feedbacks.put(feedback.getFeedbackID(), feedback);
    }

    public Feedback getFeedback(int feedbackID) {
        return feedbacks.get(feedbackID);
    }

    public List<Feedback> getAllFeedbacks() {
        return new ArrayList<>(feedbacks.values());
    }

    public void removeFeedback(int feedbackID) {
        feedbacks.remove(feedbackID);
    }

    public List<Feedback> getFeedbackByOrderID(int orderID) {
        List<Feedback> feedbackList = new ArrayList<>();
        for (Feedback feedback : feedbacks.values()) {
            if (feedback.getOrderID() == orderID) {
                feedbackList.add(feedback);
            }
        }
        return feedbackList;
    }

    // --- Promotion Management ---
    public void addPromotion(Promotion promotion) {
        promotions.put(promotion.getPromotionID(), promotion);
    }

    public Promotion getPromotion(int promotionID) {
        return promotions.get(promotionID);
    }

    public List<Promotion> getAllPromotions() {
        return new ArrayList<>(promotions.values());
    }

    public void removePromotion(int promotionID) {
        promotions.remove(promotionID);
    }

    public List<Promotion> getActivePromotions() {
        List<Promotion> activePromotions = new ArrayList<>();
        for (Promotion promotion : promotions.values()) {
            if (promotion.isPromotionActive()) {
                activePromotions.add(promotion);
            }
        }
        return activePromotions;
    }

    // --- Payment Management ---
    public void addPayment(Payment payment) {
        payments.put(payment.getPaymentID(), payment);
    }

    public Payment getPayment(int paymentID) {
        return payments.get(paymentID);
    }

    public List<Payment> getAllPayments() {
        return new ArrayList<>(payments.values());
    }

    public void removePayment(int paymentID) {
        payments.remove(paymentID);
    }
}





























Feedback class,





package Components;

import java.time.LocalDate;
import java.time.LocalDateTime;

public class Feedback {
    private static int idCount = 1;
    private final int feedbackID;
    private final int userID;
    private final int orderID;
    private double rating;
    private String comments;
    private final LocalDateTime submissionDate;
    
    public Feedback(int userID,
            int orderID,
            double rating,
            String comments)
    {
        this.feedbackID = idCount++;
        this.userID = userID;
        this.orderID = orderID;
        this.rating = rating;
        this.comments = comments;
        this.submissionDate = LocalDateTime.now();
    }
    
    
    // Getters and setters
    
    public int getFeedbackID() { return feedbackID; }
    
    public int getUserID() { return userID; }
    
    public int getOrderID() { return orderID; }
    
    public double getRating() { return rating; }
    public void setRating(double rating) {
        if (rating >= 1 && rating <= 5) {
            this.rating = rating;
        } else {
            throw new IllegalArgumentException("Rating must be between 1 and 5;");
        }
    }
    
    public String getComments() { return comments; }
    public void setComment(String comments) { this.comments = comments; }
    
    public LocalDateTime getSubmissionDate() { return submissionDate; }
    
    @Override
    public String toString() {
        return "Feedback{" +
                "feedbackId=" + feedbackID +
                ", userId=" + userID +
                ", orderId=" + orderID +
                ", rating=" + rating +
                ", comments='" + comments + '\'' +
                ", submissionDate=" + submissionDate;
    }
}























Order class,





package Components;

import Design_Patterns.Observer;
import Design_Patterns.OrderState;
import Design_Patterns.PlacedState;
import Design_Patterns.Subject;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

public class Order implements Subject {
    private static int orderCounter = 1;
    private final int orderID;
    private String status;
    private String deliveryType;
    private String deliveryAddress;
    private String estimatedDeliveryTime;
    private List<Observer> observers;
    private OrderState currentState;
    
    public Order(int orderID) {
        this.orderID = orderCounter++;
        this.status = "Placed";
        this.observers = new ArrayList<>();
        this.currentState = new PlacedState();
        this.deliveryType = "Pickup";
    }
    
    public Order(String deliveryAddress, String deliveryTime) {
        this.orderID = orderCounter++;
        this.status = "Placed";
        this.deliveryType = "Delivery";
        this.deliveryAddress = deliveryAddress;
        this.estimatedDeliveryTime = deliveryTime;
        this.observers = new ArrayList<>();
        this.currentState = new PlacedState();
    }
    
    // Getters and setters
    
    public int getOrderID() { return orderID; }
    
    public String getStatus() { return status; }
    public void setStatus(String status) {
        this.status = status;
        notifyObservers();
    }
    
    public String getDeliveryType() {
        return deliveryType;
    }
    
    public String getDeliveryAddress() {
        return deliveryAddress;
    }
    
    public String getEstimatedDeliveryTime() {
        return estimatedDeliveryTime;
    }
    
    // Observer management
    
    @Override
    public void registerObserver(Observer observer) { observers.add(observer); }
    
    @Override
    public void removeObserver(Observer observer) { observers.remove(observer); }
    
    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(status);
        }
    }
    
    // Related to order state management
    
    public OrderState getCurrentState() { return currentState; }
    public void setState(OrderState state) { this.currentState = state; }
    public void nextState() {
        if (currentState != null) {
            currentState.handleState(this);
        } else {
            System.out.println("No current state set. Cannot transition.");
        }
    }
    public String getStateName() { return currentState.getStateName(); }
    
    @Override
    public String toString() {
        if (deliveryType.equals("Delivery")) {
            return "Order," +
                "orderId=" + orderID +
                ", status='" + status + '\'' +
                ", deliveryType='" + deliveryType + '\'' +
                ", deliveryAddress='" + deliveryAddress + '\'' +
                ", estimatedDeliveryTime=" + estimatedDeliveryTime;
        } else {
            return "Order," +
                "orderId=" + orderID +
                ", status='" + status + '\'' +
                ", deliveryType='" + deliveryType + '\'';
        }
    }
}
























Payment class,




package Components;

import java.time.LocalDateTime;

public class Payment {
    private static int counter;
    private final int paymentID;
    private final int orderID;
    private String paymentMethod;
    private double amount;
    private String paymentStatus;
    private LocalDateTime paymentDate;
    
    public Payment(int orderID, String paymentMethod, double amount)
    {
        this.paymentID = counter++;
        this.orderID = orderID;
        this.paymentMethod = paymentMethod;
        this.amount = amount;
        this.paymentStatus = "Pending";
        this.paymentDate = LocalDateTime.now();
    }
    
    
    // Getters and setters
    
    public int getPaymentID() { return paymentID; }
    
    public int getOrderID() { return orderID; }
    
    public String getPaymentMethod() { return paymentMethod; }
    public void setPaymentMethod(String paymentMethod) { this.paymentMethod = paymentMethod; }
    
    public double getAmount() { return amount; }
    public void setAmount(double amount) { this.amount = amount; }
    
    public String getPaymentStatus() { return paymentStatus; }
    public void setPaymentStatus(String paymentStatus) { this.paymentStatus = paymentStatus; }
    
    public LocalDateTime getPaymentDate() { return paymentDate; }
    
    
    // Functions
    
    public void processPayment() {
        if (amount > 0) {
            this.paymentStatus = "Completed";
        } else {
            this.paymentStatus = "Failed";
        }
    }
    
    public boolean isPaymentSuccessful() {
        return "Completed".equals(paymentStatus);
    }
    
    @Override
    public String toString() {
        return "Payment{" +
                "paymentId=" + paymentID +
                ", orderId=" + orderID +
                ", paymentMethod='" + paymentMethod + '\'' +
                ", amount=" + amount +
                ", paymentStatus='" + paymentStatus + '\'' +
                ", paymentDate=" + paymentDate +
                '}';
    }
}























Pizza class,








package Components;

import java.util.ArrayList;
import java.util.List;

public class Pizza {
    
    // Local variables
    
    private static int idCounter = 1;
    private final int pizzaID;
    private String name;
    private String description;
    private String crustType;
    private String sauceType;
    private String size;
    private List<String> toppings;
    private double basePrice;
    private double rating;
    
    public Pizza(String name,
        String description,
        String crustType,
        String sauceType,
        String size,
        List<String> toppings,
        double basePrice,
        double rating)
    {
        this.pizzaID = idCounter++;
        this.name = name;
        this.description = description;
        this.crustType = crustType;
        this.sauceType = sauceType;
        this.size = size;        
        this.toppings = new ArrayList<>(toppings);
        this.basePrice = basePrice;
        this.rating = rating;
    }
    
    
    // Getters and setters
    
    public int getPizzaID() { return pizzaID; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    public String getCrustType() { return crustType; }
    public void setCrustType(String crustType) { this.crustType = crustType; }
    
    public String getSauceType() { return sauceType; }
    
    public String getSize() { return size; }
    public void setSize(String size) { this.size = size; }
    
    public List<String> getToppings() { return toppings; }
    public void setToppings(List<String> toppings) { this.toppings = toppings; }
    
    public double getBasePrice() { return basePrice; }
    public void setBasePrice(double basePrice) { this.basePrice = basePrice; }
    
    public double getRating() { return rating; }
    public void setRating(double rating) { this.rating = rating; }
    
    
    // Functions
    
    public double calculatePrice() {
        return basePrice;
    }
    
    @Override
    public String toString() {
        return "Pizza (" + pizzaID + "): " + name + "\n" + "Description: " + description + "\n"
                + "Crust Type: " + crustType + "\n"
                + "Size: " + size + "\n"
                + "Toppings: " + toppings + "\n"
                + "Price: Rs." + basePrice + "\n"
                + "Rating: " + rating + "\n";
    }
}

























Promotion class,




package Components;

import java.time.LocalDate;
import java.util.List;

public class Promotion {
    private static int counter = 1;
    private final int promotionID;
    private String name;
    private String description;
    private double discount;
    private boolean isPercentage;
    private LocalDate startDate;
    private LocalDate endDate;
    private List<Integer> eligibleItems;
    
    public Promotion(String name,
        String description,
        double discount,
        boolean isPercentage,
        LocalDate startDate,
        LocalDate endDate,
        List<Integer> eligibleItems)
    {
        this.promotionID = counter++;
        this.name = name;
        this.description = description;
        this.discount = discount;
        this.isPercentage = isPercentage;
        this.startDate = startDate;
        this.endDate = endDate;
        this.eligibleItems = eligibleItems;
    }

    
    // Getters and setters
    
    public int getPromotionID() {
        return promotionID;
    }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    
    public double getDiscount() { return discount; }
    public void setDiscount(double discount) { this.discount = discount; }
    
    public boolean isPercentage() { return isPercentage; }
    public void setPercentage(boolean percentage) { this.isPercentage = percentage; }
    
    public LocalDate getStartDate() { return startDate; }
    public void setStartDate(LocalDate startDate) { this.startDate = startDate; }
    
    public LocalDate getEndDate() { return endDate; }
    public void setEndDate(LocalDate endDate) { this.endDate = endDate; }
    
    public List<Integer> getEligibleItems() { return eligibleItems; }
    public void setEligibleItems(List<Integer> eligibleItems) { this.eligibleItems = eligibleItems; }
    
    
    // Promotion related functions
    
    public boolean isPromotionActive() {
        LocalDate today = LocalDate.now();
        return (today.isEqual(startDate) || today.isAfter(startDate)) && today.isBefore(endDate.plusDays(1));
    }
    
    public double applyPromotion(double price) {
        if (isPercentage) {
            return price - (price * (discount / 100));
        } else {
            return price - discount;
        }
    }
    
    @Override
    public String toString() {
        return "Promotion (" + promotionID + ": " + name + ")" + "\n" +
                "Description: " + description + "\n" +
                "Discount: " + (isPercentage ? discount + "%" : "Rs." + discount) + "\n" +
                "Start Date: " + startDate + "\n" +
                "End Date: " + endDate + "\n" +
                "Eligible Items:  \n" +
                eligibleItems + "\n";
    }
}


























User class,




package Components;

import Design_Patterns.Observer;
import java.util.ArrayList;
import java.util.List;

public class User implements Observer {
    private static int counter = 1;
    private final int userID;
    private String name;
    private String email;
    private String phoneNumber;
    private double loyaltyPoints;
    private List<Pizza> favorites;
    
    public User(String name, String email, String phoneNumber) {
        this.userID = counter++;
        this.name = name;
        this.email = email;
        this.phoneNumber = phoneNumber;
        this.loyaltyPoints = 0;
        this.favorites = new ArrayList<>();
    }
    
    // Observer method
    
    @Override
    public void update(String orderStatus) {
        System.out.println("User " + name +" notified: Order status updated to " + orderStatus);
    }
    
    // Getters and setters
    
    public int getUserID() { return userID; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    
    public String getPhoneNumber() { return phoneNumber; }
    public void setPhoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; }
    
    public double getLoyaltyPoints() { return loyaltyPoints; }
    public void addLoyaltyPoiints(double points) { this.loyaltyPoints += points; }
    
    public List<Pizza> getFavorites() { return favorites; }
    
    
    // Functions
    
    public void redeemLoyaltyPoints(double points) {
        if (this.loyaltyPoints >= points) {
            this.loyaltyPoints -= points;
        } else {
            System.out.println("Not enough loyalty points to redeem.");
        }
    }
    
    public void addFavoritePizza(Pizza pizza) {
        favorites.add(pizza);
    }
    
    public void removeFavoritePizza(int pizzaID) {
        favorites.removeIf(p -> p.getPizzaID() == pizzaID);
    }
    
    @Override
    public String toString() {
        return "User (" + userID + "): " + name + "\n"
                + "Email: " + email + "\n"
                + "Phone Number: " + phoneNumber + "\n"
                + "Loyalty Points: " + loyaltyPoints + "\n"
                + "Favorites: \n\n" + favorites + "\n";
    }
    
}



















Observer class,


package Design_Patterns;

public interface Observer {
    void update(String orderStatus);
}




Subject class,


package Design_Patterns;

public interface Subject {
    void registerObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers();
}



















PizzaBuilder class,




package Design_Patterns;

import Components.Pizza;
import java.util.ArrayList;
import java.util.List;

public class PizzaBuilder {
    private String name = "Custom Pizza";
    private String description = "Customized Pizza";
    private String crustType = "Thin Crust";
    private String sauceType = "Tomato Basil";
    private String size = "Medium";
    private List<String> toppings = new ArrayList<>();
    private double basePrice;
    private double rating;
    
    public PizzaBuilder setName(String name) {
        this.name = name;
        return this;
    }
    
    public PizzaBuilder setDescription(String description) {
        this.description = description;
        return this;
    }
    
    public PizzaBuilder setSauceType(String sauceType) {
        this.sauceType = sauceType;
        return this;
    }
    
    public PizzaBuilder setCrustType(String crustType) {
        this.crustType = crustType;
        return this;
    }
    
    public PizzaBuilder setsize(String size) {
        this.size = size;
        return this;
    }
    
    public PizzaBuilder addTopping(List<String> newTopping) {
        this.toppings.addAll(newTopping);
        return this;
    }
    
    public PizzaBuilder setBasePrice(double basePrice) {
        this.basePrice = basePrice;
        return this;
    }
    
    public PizzaBuilder setRating(double rating) {
        this.rating = rating;
        return this;
    }
    
    public Pizza build() {
        return new Pizza(name, description, crustType, sauceType, size, toppings, basePrice, rating);
    }
}













OrderState Class,


package Design_Patterns;

import Components.Order;

public interface OrderState {
    void handleState(Order order);
    String getStateName();
}











PlacedState Class,


package Design_Patterns;
import Components.Order;

public class PlacedState implements OrderState {
    @Override
    public void handleState(Order order) {
        System.out.println("Order is Placed.");
        order.setState(new InPreparationState());
    }
    
    @Override
    public String getStateName() { return "Placed"; }
}












InPreparationState class,



package Design_Patterns;
import Components.Order;

public class InPreparationState implements OrderState {
    @Override
    public void handleState(Order order) {
        System.out.println("Order is In Preparation.");
        order.setState(new OutForDeliveryState());
    }
    
    @Override
    public String getStateName() { return "In Preparation"; };
}











DeliveredState class,



package Design_Patterns;

import Components.Order;

public class DeliveredState implements OrderState {
    @Override
    public void handleState(Order order) {
        System.out.println("The order has been delivered. Enjoy...");
    }
    
    @Override
    public String getStateName() { return "Delivered"; };
}











OutForDeliveryState class,



package Design_Patterns;

import Components.Order;

public class OutForDeliveryState implements OrderState {
    @Override
    public void handleState(Order order) {
        System.out.println("Order is Out for Delivery.");
        order.setState(new DeliveredState());
    }
    
    @Override
    public String getStateName() { return "Out for Delivery"; };
}














LoyaltyPointsPayment class,



package Design_Patterns;

public class LoyaltyPointsPayment implements PaymentStrategy {
    private int availablepoints;
    
    public LoyaltyPointsPayment(int availablePoints) {
        this.availablepoints = availablePoints;
    }
    
    @Override
    public void pay(double amount) {
        if (availablepoints >= amount) {
            availablepoints -= amount;
            System.out.println("Paid Rs." + amount + " using Loyalty Points.");
        } else {
            System.out.println("Insufficient loyalty points for this payment.");
        }
    }
}










WalletPayment class,


package Design_Patterns;

public class WalletPayment implements PaymentStrategy {
    private String walletID;
    
    public WalletPayment(String walletID) {
        this.walletID = walletID;
    }
    
    @Override
    public void pay(double amount) {
        System.out.println("Paid Rs." + amount + " using Digital Wallet (ID:)" + walletID + ").");
    }
}
















CreditCardPayment class,



package Design_Patterns;

public class CreditCardPayment implements PaymentStrategy {
    private String cardNumber;
    private String cardHolderName;
    
    public CreditCardPayment(String cardNumber, String cardHolderName) {
        this.cardNumber = cardNumber;
        this.cardHolderName = cardHolderName;
    }
    
    @Override
    public void pay(double amount) {
        System.out.println("Paid Rs." + amount + " using Credit Card.");
    }
}












PaymentProcessor class,




package Design_Patterns;

public class PaymentProcessor {
    private PaymentStrategy paymentStrategy;
    
    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }
    
    public void processPayment(double amount) {
        if (paymentStrategy != null) {
            paymentStrategy.pay(amount);
        } else {
            System.out.println("No payment method selected.");
        }
    }
}









PaymentStrategy class,



package Design_Patterns;

public interface PaymentStrategy {
    void pay(double amount);
}





















PizzaDecorator class,




package Design_Patterns;

import Components.*;

public abstract class PizzaDecorator extends Pizza {
    protected Pizza pizza;
    
    public PizzaDecorator(Pizza pizza) {
        super(pizza.getName(), pizza.getDescription(), pizza.getCrustType(), pizza.getSauceType(), pizza.getSize(), pizza.getToppings(), pizza.getBasePrice(), pizza.getRating());
        this.pizza = pizza;
    }
    
    @Override
    public abstract String getDescription();
    
    @Override
    public abstract double calculatePrice();
}

















ExtraCheeseDecorator class,



package Design_Patterns;

import Components.*;

public class ExtraCheeseDecorator extends PizzaDecorator {
    private static final double extraCheeseCost = 300.0;
    
    public ExtraCheeseDecorator(Pizza pizza) {
        super(pizza);
    }
    
    @Override
    public String getDescription() {
        return pizza.getDescription() + ", Extra Chesse";
    }
    
    @Override
    public double calculatePrice() {
        return pizza.calculatePrice() + extraCheeseCost;
    }
}














ExtraPepperoniDecorator class,


package Design_Patterns;

import Components.Pizza;

public class ExtraPepperoniDecorator extends PizzaDecorator {
    private static final double extraPepperoni = 300.0;
    
    public ExtraPepperoniDecorator(Pizza pizza) {
        super(pizza);
    }
    
    @Override
    public String getDescription() {
        return pizza.getDescription() + ", Extra Pepperoni";
    }
    
    @Override
    public double calculatePrice() {
        return pizza.calculatePrice() + extraPepperoni;
    }
}
















ExtraSausageDecorator class,



package Design_Patterns;

import Components.Pizza;

public class ExtraSausageDecorator extends PizzaDecorator {
    private static final double extraSausage = 300.0;
    
    public ExtraSausageDecorator(Pizza pizza) {
        super(pizza);
    }
    
    @Override
    public String getDescription() {
        return pizza.getDescription() + ", Extra Sausage";
    }
    
    @Override
    public double calculatePrice() {
        return pizza.calculatePrice() + extraSausage;
    }
}













PremiumToppingDecorator class,


package Design_Patterns;

import Components.*;

public class SpecialPackagingDecorator extends PizzaDecorator {
    private static final double packagingCost = 100.0;
    
    public SpecialPackagingDecorator(Pizza pizza) {
        super(pizza);
    }
    
    @Override
    public String getDescription() {
        return pizza.getDescription() + ", Special Packaging";
    }
    
    @Override
    public double calculatePrice() {
        return pizza.calculatePrice() + packagingCost;
    }
}

















SpecialPackagingDecorator class,



package Design_Patterns;

import Components.*;

public class SpecialPackagingDecorator extends PizzaDecorator {
    private static final double packagingCost = 100.0;
    
    public SpecialPackagingDecorator(Pizza pizza) {
        super(pizza);
    }
    
    @Override
    public String getDescription() {
        return pizza.getDescription() + ", Special Packaging";
    }
    
    @Override
    public double calculatePrice() {
        return pizza.calculatePrice() + packagingCost;
    }
}


















CustomizationHandler class,



package Design_Patterns;

import Components.*;

public abstract class CustomizationHandler {
    protected CustomizationHandler nextHandler;
    
    public void setNextHandler(CustomizationHandler nextHandler) {
        this.nextHandler = nextHandler;
    }
    
    public abstract void handleRequest(Pizza pizza, String customization);
}


























CrustHandler class,


package Design_Patterns;

import Components.*;

public class CrustHandler extends CustomizationHandler {
    @Override
    public void handleRequest(Pizza pizza, String customization) {
        if (customization.startsWith("Crust:")) {
            String crustType = customization.split(":")[1];
            pizza.setCrustType(crustType);
            System.out.println("Crust set to: " + crustType);
        } else if (nextHandler != null) {
            nextHandler.handleRequest(pizza, customization);
        }
    }
}


















SauceHandler class,

package Design_Patterns;

import Components.*;

public class SauceHandler extends CustomizationHandler {
    @Override
    public void handleRequest(Pizza pizza, String customization) {
        if (customization.startsWith("Sauce:")) {
            String sauceType = customization.split(":")[1];
            pizza.setDescription(pizza.getDescription() + ", Sauce: " + sauceType);
            System.out.println("Sauce added: " + sauceType);
        } else {
            nextHandler.handleRequest(pizza, customization);
        }
    }
}
















ToppingHandler class,


package Design_Patterns;

import Components.*;
import java.util.List;

public class ToppingHandler extends CustomizationHandler {
    @Override
    public void handleRequest(Pizza pizza, String customization) {
        if (customization.startsWith("Topping:")) {
            String topping = customization.split(":")[1];
            List<String> toppings = pizza.getToppings();
            toppings.add(topping);
            pizza.setToppings(toppings); 
            System.out.println("Topping added: " + topping);
        } else if (nextHandler != null) {
            nextHandler.handleRequest(pizza, customization);
        }
    }
}
















Command class,


package Design_Patterns;

public interface Command {
    void execute();
    void undo();
    String getCommandLog();
}









CommandManager class,



package Design_Patterns;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class CommandManager {
    private Queue<Command> commandQueue = new LinkedList<>();
    private List<String> commandLog = new ArrayList<>();

    public void addCommand(Command command) {
        commandQueue.add(command);
    }

    public void executeCommands() {
        while (!commandQueue.isEmpty()) {
            Command command = commandQueue.poll();
            command.execute();
            commandLog.add(command.getCommandLog());
        }
    }
        
    public void undoLastCommand() {
         if (!commandQueue.isEmpty()) {
             Command command = commandQueue.poll();
             command.undo();
         }
    }

    public void viewCommandLogs() {
        for (String log : commandLog) {
            System.out.println(log);
         }
    }
}













PlaceOrderCommand class,



package Design_Patterns;

import Components.*;

public class PlaceOrderCommand implements Command {
    private Order order;
    private DataRepository repository;
    
    public PlaceOrderCommand(Order order, DataRepository repository) {
        this.order = order;
        this.repository = repository;
    }
    
    @Override
    public void execute() {
        System.out.println("Placing order...");
        repository.addOrder(order);
    }
    
    @Override
    public void undo() {
        System.out.println("Undoing order placement...");
        repository.removeOrder(order.getOrderID());
    }

    @Override
    public String getCommandLog() {
        return "Place Order Command: OrderID - " + order.getOrderID();
    }
}














CancelOrderCommand class,



package Design_Patterns;

import Components.Order;

public class CancelOrderCommand implements Command {
    private Order order;

    public CancelOrderCommand(Order order) {
        this.order = order;
    }

    @Override
    public void execute() {
        System.out.println("Canceling order...");
        order.setStatus("Canceled");
    }

    @Override
    public void undo() {
        System.out.println("Undoing order cancellation...");
        order.setStatus("Placed");
    }

    @Override
    public String getCommandLog() {
        return "Cancel Order Command: OrderID - " + order.getOrderID();
    }
}















ProvideFeedbackCommand class,





package Design_Patterns;

import Components.DataRepository;
import Components.Feedback;

public class ProvideFeedbackCommand implements Command {
    private Feedback feedback;
    private DataRepository repository;

    public ProvideFeedbackCommand(Feedback feedback, DataRepository repository) {
        this.feedback = feedback;
        this.repository = repository;
    }

    @Override
    public void execute() {
        System.out.println("Submitting feedback...");
        repository.addFeedback(feedback);
        System.out.println("Feedback submitted successfully:\n" + feedback);
    }

    @Override
    public void undo() {
        System.out.println("Undoing feedback submission...");
        repository.removeFeedback(feedback.getFeedbackID());
    }

    @Override
    public String getCommandLog() {
        return "Provide Feedback Command: FeedbackID - " + feedback.getFeedbackID();
    }
}




















PromotionStrategy class,



package Design_Patterns;

import Components.Pizza;

public interface PromotionStrategy {
    boolean isEligible(Pizza pizza);
    double applyDiscount(Pizza pizza);
    String getPromotionDetails();
}


















ToppingDiscountPromotion class,


package Design_Patterns;

import Components.Pizza;

public class ToppingDiscountPromotion implements PromotionStrategy {
    private String eligibleTopping;
    private double discount;

    public ToppingDiscountPromotion(String eligibleTopping, double discount) {
        this.eligibleTopping = eligibleTopping;
        this.discount = discount;
    }

    @Override
    public boolean isEligible(Pizza pizza) {
        return pizza.getToppings().contains(eligibleTopping);
    }

    @Override
    public double applyDiscount(Pizza pizza) {
        return pizza.getBasePrice() - discount;
    }

    @Override
    public String getPromotionDetails() {
        return "Discount of Rs." + discount + " on pizzas with " + eligibleTopping + " topping.";
    }
}
















SizeDiscountPromotion class,


package Design_Patterns;

import Components.Pizza;

public class SizeDiscountPromotion implements PromotionStrategy {
    private String eligibleSize;
    private double discount;

    public SizeDiscountPromotion(String eligibleSize, double discount) {
        this.eligibleSize = eligibleSize;
        this.discount = discount;
    }

    @Override
    public boolean isEligible(Pizza pizza) {
        return pizza.getSize().equalsIgnoreCase(eligibleSize);
    }

    @Override
    public double applyDiscount(Pizza pizza) {
        return pizza.getBasePrice() - discount;
    }

    @Override
    public String getPromotionDetails() {
        return "Discount of Rs." + discount + " on " + eligibleSize + " pizzas.";
    }
}













PromotionManager class,


package Design_Patterns;

import Design_Patterns.PromotionStrategy;
import java.util.ArrayList;
import java.util.List;

import Components.Pizza;

public class PromotionManager {
    private List<PromotionStrategy> promotions;

    public PromotionManager() {
        this.promotions = new ArrayList<>();
    }

    public void addPromotion(PromotionStrategy promotion) {
        promotions.add(promotion);
    }

    public List<PromotionStrategy> getActivePromotions() {
        return promotions;
    }

    public List<Pizza> getPizzasWithPromotions(List<Pizza> allPizzas) {
        List<Pizza> pizzasWithPromotions = new ArrayList<>();
        for (Pizza pizza : allPizzas) {
            for (PromotionStrategy promotion : promotions) {
                if (promotion.isEligible(pizza)) {
                    pizzasWithPromotions.add(pizza);
                    break;
                }
            }
        }
        return pizzasWithPromotions;
    }
}






























































